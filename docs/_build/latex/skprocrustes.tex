%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{skprocrustes Documentation}
\date{Jul 12, 2017}
\release{0.1}
\author{Melissa Weber Mendonça}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


Collection of solvers for the (Weighted) Orthogonal Procrustes Problem.
\begin{quote}
\begin{equation*}
\begin{split}\min  {\| AXC-B \|}_F^2 \qquad s. t. \quad X^TX=I\end{split}
\end{equation*}\end{quote}

where \(A_{m \times n}, B_{m \times q}, C_{p \times q},
X_{n \times p}\). Usually n \textgreater{}\textgreater{} p, which means we can solve unbalanced problems.


\chapter{Available Solvers}
\label{\detokenize{index:available-solvers}}\label{\detokenize{index:scikit-procrustes}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{solvers:spg}]{\sphinxcrossref{\DUrole{std,std-ref}{spg}}}}    Nonmonotone Spectral Projected Gradient Method for the (unbalanced) WOPP, as described in %
\begin{footnote}[1]\sphinxAtStartFootnote
J.B. Francisco, F.S. Viloche Bazán, Nonmonotone algorithm for minimization on closed sets with applications to minimization on Stiefel manifolds, Journal of Computational and Applied Mathematics, 2012, 236(10): 2717\textendash{}2727 \textless{}\sphinxurl{http://dx.doi.org/10.1016/j.cam.2012.01.014}\textgreater{}
%
\end{footnote}.

\item {} 
{\hyperref[\detokenize{solvers:gkb}]{\sphinxcrossref{\DUrole{std,std-ref}{gkb}}}}    Nonmonotone Spectral Projected Gradient Method using incomplete Lanczos (Golub-Kahan) Bidiagonalization, as described in %
\begin{footnote}[2]\sphinxAtStartFootnote
J.B. Francisco, F.S. Viloche Bazán and M. Weber Mendonça, Non-monotone algorithm for minimization on arbitrary domains with applications to large-scale orthogonal Procrustes problem, Applied Numerical Mathematics, 2017, 112: 51\textendash{}64 \textless{}\sphinxurl{https://doi.org/10.1016/j.apnum.2016.09.018}\textgreater{}
%
\end{footnote}.

\item {} 
{\hyperref[\detokenize{solvers:eb}]{\sphinxcrossref{\DUrole{std,std-ref}{eb}}}}      Expansion-Balance method, as described in %
\begin{footnote}[3]\sphinxAtStartFootnote
J.M.F. ten Berge and D.L. Knol, Orthogonal rotations to maximal agreement for two or more matrices of different column orders, Psychometrika 1984, 49: 49\textendash{}55 \textless{}\sphinxurl{https://doi:10.1007/BF02294205}\textgreater{}
%
\end{footnote}.

\item {} 
{\hyperref[\detokenize{solvers:gpi}]{\sphinxcrossref{\DUrole{std,std-ref}{gpi}}}}    Generalized Power Iteration for the WOPP, as described in %
\begin{footnote}[5]\sphinxAtStartFootnote
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
Nie, R. Zhang, X. Li, A generalized power iteration method for solving quadratic problem on the Stiefel manifold, Sci. China Inf. Sci., 2017, 60: 112101:1\textendash{}112101:10. \textless{}\sphinxurl{http://dx.doi.org/10.1007/s11432-016-9021-9}\textgreater{}

\end{enumerate}
%
\end{footnote}.

\end{itemize}


\chapter{Usage}
\label{\detokenize{index:usage}}
To use the package to solve a given problem with predefined matrices A, B and C
using the SPG solver, for example, use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{skprocrustes} \PYG{k}{as} \PYG{n+nn}{skp}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{problem} \PYG{o}{=} \PYG{n}{skp}\PYG{o}{.}\PYG{n}{ProcrustesProblem}\PYG{p}{(}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{n}{n}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{q}\PYG{p}{)}\PYG{p}{,}     \PYG{c+c1}{\PYGZsh{} tuple}
\PYG{g+go}{                                    matrices=[A, B, C])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mysolver} \PYG{o}{=} \PYG{n}{skp}\PYG{o}{.}\PYG{n}{SPGSolver}\PYG{p}{(}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result} \PYG{o}{=} \PYG{n}{mysolver}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{problem}\PYG{p}{)}
\end{sphinxVerbatim}

where \sphinxtitleref{**kwargs} are the selected solver’s options (see the \sphinxhref{skprocrustes.html}{Module Reference} for more details).

To use the package to solve one of the three predefined problems (as described in %
\begin{footnote}[4]\sphinxAtStartFootnote
\begin{enumerate}
\setcounter{enumi}{25}
\item {} 
Zhang, K. Du, Successive projection method for solving the unbalanced Procrustes problem, Sci. China Ser. A, 2006, 49: 971\textendash{}986.

\end{enumerate}
%
\end{footnote}), using the GKB solver, for example, use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{skprocrustes} \PYG{k}{as} \PYG{n+nn}{skp}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{problem} \PYG{o}{=} \PYG{n}{skp}\PYG{o}{.}\PYG{n}{ProcrustesProblem}\PYG{p}{(}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{n}{n}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{q}\PYG{p}{)}\PYG{p}{,}     \PYG{c+c1}{\PYGZsh{} tuple}
\PYG{g+go}{                                    problemnumber=1)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mysolver} \PYG{o}{=} \PYG{n}{skp}\PYG{o}{.}\PYG{n}{GKBSolver}\PYG{p}{(}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result} \PYG{o}{=} \PYG{n}{mysolver}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{problem}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{References}
\label{\detokenize{index:references}}\label{\detokenize{index:bibliography}}

\chapter{Installation}
\label{\detokenize{index:installation}}

\section{Quick Installation}
\label{\detokenize{index:quick-installation}}
In the root directory of the package, just do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py} \PYG{n}{install}
\end{sphinxVerbatim}


\section{Latest Software}
\label{\detokenize{index:latest-software}}
The latest software can be downloaded from \sphinxhref{https://github.com/melissawm/scikit-procrustes}{GitHub}


\section{Installation Dependencies}
\label{\detokenize{index:installation-dependencies}}
\sphinxcode{scikit-procrustes} requires the following software packages to be
installed:
\begin{itemize}
\item {} 
\sphinxhref{http://www.python.org}{Python} 3.6.1 or later.

\item {} 
\sphinxhref{http://www.numpy.org}{NumPy} 1.13.0 or later.

\item {} 
\sphinxhref{http://www.scipy.org}{SciPy} 0.19.0 or later.

\item {} 
\sphinxhref{http://www.matplotlib.org}{Matplotlib} 2.0.2 or later.

\end{itemize}


\chapter{Contents}
\label{\detokenize{index:contents}}

\section{skprocrustes package}
\label{\detokenize{skprocrustes:skprocrustes-package}}\label{\detokenize{skprocrustes::doc}}

\subsection{Module contents}
\label{\detokenize{skprocrustes:module-skprocrustes}}\label{\detokenize{skprocrustes:module-contents}}\index{skprocrustes (module)}\index{ProcrustesProblem (class in skprocrustes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.ProcrustesProblem}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{skprocrustes.}\sphinxbfcode{ProcrustesProblem}}{\emph{sizes}, \emph{problemnumber=None}, \emph{matrices={[}{]}}}{}
Bases: \sphinxcode{object}

The problem we want to solve.

Usage example (default problem):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{skprocrustes} \PYG{k}{as} \PYG{n+nn}{skp}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{problem} \PYG{o}{=} \PYG{n}{skp}\PYG{o}{.}\PYG{n}{ProcrustesProblem}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{problemnumber}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

Usage example (user defined problem):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{skprocrustes} \PYG{k}{as} \PYG{n+nn}{skp}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{A} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{c+c1}{\PYGZsh{} given by the user}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{B} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{c+c1}{\PYGZsh{} given by the user}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{C} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{c+c1}{\PYGZsh{} given by the user}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{X} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{c+c1}{\PYGZsh{} given by the user (optional)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{problem} \PYG{o}{=} \PYG{n}{skp}\PYG{o}{.}\PYG{n}{ProcrustesProblem}\PYG{p}{(}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{n}{n}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{q}\PYG{p}{)}\PYG{p}{,} \PYG{n}{matrices}\PYG{o}{=}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{,}\PYG{n}{C}\PYG{p}{,}\PYG{n}{X}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Input Parameters:
\begin{quote}
\begin{description}
\item[{\sphinxcode{sizes}: tuple}] \leavevmode
\sphinxcode{(m,n,p,q)}, where \(A_{m\times n}, B_{m \times q}, 
C_{p\times q}\) and \(X_{n\times p}\).

\item[{\sphinxstyleemphasis{(optional)} \sphinxcode{problemnumber}: int}] \leavevmode
Can be \sphinxcode{1}, \sphinxcode{2} or \sphinxcode{3}, and selects one of the predefined
problems as described in reference {\hyperref[\detokenize{index:bibliography}]{\sphinxcrossref{\DUrole{std,std-ref}{{[}4{]}}}}}.
(for more details, see the documentation for \sphinxcode{\_setproblem})

\item[{\sphinxstyleemphasis{(optional)} \sphinxcode{matrices}: list of ndarrays}] \leavevmode
If present, must contain a list of three or four matrices 
corresponding to \(A\), \(B\), \(C\), and optionally
\(X\) (known solution) with adequate sizes.

\end{description}
\end{quote}

\begin{sphinxadmonition}{note}{Note:}
Currently, m must be equal do n, and p must be equal do q. This 
is the case for all three solvers. (However, n can be greater than
p)
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
If \sphinxcode{matrices} is not given by the user, \sphinxcode{problemnumber}
(1, 2 or 3) must be selected so that one of the default problems 
is built.
\end{sphinxadmonition}

Attributes:

The problem matrices (generated or given) are accessible via

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{problem}\PYG{o}{.}\PYG{n}{A}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{problem}\PYG{o}{.}\PYG{n}{B}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{problem}\PYG{o}{.}\PYG{n}{C}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{problem}\PYG{o}{.}\PYG{n}{Xsol}
\end{sphinxVerbatim}
\index{\_setproblem() (skprocrustes.ProcrustesProblem method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.ProcrustesProblem._setproblem}}\pysiglinewithargsret{\sphinxbfcode{\_setproblem}}{\emph{matrices}, \emph{problemnumber}}{}
Method to effectively build A, B, and C if they are not already given.

\sphinxstyleemphasis{This method should not be called directly; it is called by the 
ProcrustesProblem constructor.}

Available problems are all based on reference {\hyperref[\detokenize{index:bibliography}]{\sphinxcrossref{\DUrole{std,std-ref}{{[}4{]}}}}}:
All problems have the form
\begin{quote}
\begin{equation*}
\begin{split}A = U\Sigma V^T\end{split}
\end{equation*}\end{quote}

where \(\Sigma\) varies between problems, and
\begin{quote}
\begin{equation*}
\begin{split}U = I_{m\times m} - 2uu^T\\
V = I_{n\times n} - 2vv^T\end{split}
\end{equation*}\end{quote}

where \(u\) and \(v\) are randomly generated using 
\sphinxcode{np.random.randn} (normal distribution) and then normalized.

\(C\) can be built, but for our predefined problems it is always
the identity matrix.
\begin{description}
\item[{\sphinxcode{problemnumber = 1}:}] \leavevmode
Well conditioned problem: the singular values are randomly and 
uniformly distributed in the interval {[}10,12{]}.

\item[{\sphinxcode{problemnumber = 2}:}] \leavevmode
For this problem, the singular values are
\begin{quote}
\begin{equation*}
\begin{split}\sigma_i = 1 + \frac{99(i-1)}{(m-1)} + 2r_i\end{split}
\end{equation*}\end{quote}

and \(r_i\) are random numbers chosen from a uniform distribution
on the interval {[}0,1{]}.

\item[{\sphinxcode{problemnumber = 3}:}] \leavevmode
For this problem, the singular values are
\begin{quote}
\begin{equation*}
\begin{split}\sigma_i = \left\{ 
\begin{array}{l l}
10 + r, & \qquad 1\leq i \leq m_1\\
5 + r, & \qquad m_1+1\leq i \leq m_2\\
2 + r, & \qquad m_2+1\leq i \leq m_3\\
\frac{r}{1000}, & \qquad m_3+1\leq i\leq m
\end{array}
\right.\end{split}
\end{equation*}\end{quote}

Thus, \(A\) has several small singular values and is 
ill-conditioned.

\end{description}

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{problemnumber = 3} can only be used if \(n = 50\), 
\(n = 95\), \(n = 500\) or \(n = 1000\).
\end{sphinxadmonition}

\end{fulllineitems}


\end{fulllineitems}

\index{OptimizeResult (class in skprocrustes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.OptimizeResult}}\pysigline{\sphinxbfcode{class }\sphinxcode{skprocrustes.}\sphinxbfcode{OptimizeResult}}
Bases: \sphinxcode{dict}

Represents the optimization result. 
(\sphinxstyleemphasis{based on scipy.optimize.OptimizeResult})

This class is constructed as a dictionary of parameters defined by
the creation of the instance. Thus, its attributes may vary.

Possible attributes:
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{success}}] \leavevmode{[}\sphinxcode{bool}{]}
Whether or not the optimizer exited successfully.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{status}}] \leavevmode{[}\sphinxcode{int}{]}
Termination status of the optimizer. Its value depends on the
underlying solver. Refer to \sphinxtitleref{message} for details.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{message}}] \leavevmode{[}\sphinxcode{str}{]}
Description of the cause of the termination.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{fun}}] \leavevmode{[}\sphinxcode{float}{]}
Value of the objective function at the solution.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{normgrad}}] \leavevmode{[}\sphinxcode{float}{]}
Value of the norm of the gradient at the solution.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{nbiter}}] \leavevmode{[}\sphinxcode{int}{]}
Number of iterations performed by the optimizer.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{nfev}}] \leavevmode{[}\sphinxcode{int}/\sphinxcode{float}{]}
Number of evaluations of the objective function (if called by 
GKBSolver, nfev is a float representing the proportional number
of calls to the objective function at each block step).

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{blocksteps}}] \leavevmode{[}\sphinxcode{int}{]}
Number of blocksteps performed (if called by GKBSolver)

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{total\_fun}: list}] \leavevmode
List of objective function values for each iteration performed 
(used to report and compare algorithms). Only if \sphinxcode{full\_results}
is True.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{total\_grad}: list}] \leavevmode
List of gradient norm values for each iteration performed 
(used to report and compare algorithms). Only if \sphinxcode{full\_results}
is True, and only for SPGSolver and GKBSolver.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{total\_crit}: list}] \leavevmode
List of criticality measure values for each iteration performed 
(used to report and compare algorithms). Only if \sphinxcode{full\_results}
is True, and only for EBSolver and GPISolver.

\end{description}

\end{itemize}

Notes:
There may be additional attributes not listed above depending of the
specific solver. Since this class is essentially a subclass of dict
with attribute accessors, one can see which attributes are available
using the \sphinxtitleref{keys()} method.

\end{fulllineitems}

\index{ProcrustesSolver (class in skprocrustes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.ProcrustesSolver}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{skprocrustes.}\sphinxbfcode{ProcrustesSolver}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{object}

Abstract class to implement a solver for the ProcrustesProblem.

All subclasses should implement the following methods:
\index{\_setoptions() (skprocrustes.ProcrustesSolver method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.ProcrustesSolver._setoptions}}\pysiglinewithargsret{\sphinxbfcode{\_setoptions}}{\emph{*args}, \emph{**kwargs}}{}
Choose which options are valid and applicable to this solver.

\end{fulllineitems}

\index{solve() (skprocrustes.ProcrustesSolver method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.ProcrustesSolver.solve}}\pysiglinewithargsret{\sphinxbfcode{solve}}{\emph{*args}, \emph{**kwargs}}{}
Call a solver function and set up the \sphinxcode{OptimizeResult} instance with
the result and statistics as convenient for this solver. Should be
something like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{output} \PYG{o}{=} \PYG{n}{somesolver}\PYG{p}{(}\PYG{n}{problem}\PYG{p}{,} \PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{OptimizeResult}\PYG{p}{(}\PYG{n}{output}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{result}
\end{sphinxVerbatim}

\end{fulllineitems}


\end{fulllineitems}

\index{SPGSolver (class in skprocrustes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.SPGSolver}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{skprocrustes.}\sphinxbfcode{SPGSolver}}{\emph{**kwargs}}{}
Bases: \sphinxcode{skprocrustes.skprocrustes.ProcrustesSolver}

Subclass containing the call to the \sphinxcode{spectral\_setup()} function 
corresponding to the Spectral Projected Gradient solver described in 
{\hyperref[\detokenize{index:bibliography}]{\sphinxcrossref{\DUrole{std,std-ref}{{[}1{]}}}}} and {\hyperref[\detokenize{index:bibliography}]{\sphinxcrossref{\DUrole{std,std-ref}{{[}2{]}}}}}.

Usage example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mysolver} \PYG{o}{=} \PYG{n}{skp}\PYG{o}{.}\PYG{n}{SPGSolver}\PYG{p}{(}\PYG{n}{verbose}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result} \PYG{o}{=} \PYG{n}{mysolver}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{problem}\PYG{p}{)}
\end{sphinxVerbatim}

Input:
\begin{description}
\item[{\sphinxcode{key = value}: keyword arguments available}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{full\_results}: (\sphinxstyleemphasis{default}: \sphinxcode{False})}] \leavevmode
Return list of criticality values at each iteration (for later
comparison between solvers)

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{strategy}: (\sphinxstyleemphasis{default}: \sphinxcode{"newfw"})}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{"monotone"}: }] \leavevmode
monotone trust region

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{"bazfr"}}] \leavevmode{[}{]}
nonmonotone method according to {\hyperref[\detokenize{index:bibliography}]{\sphinxcrossref{\DUrole{std,std-ref}{{[}1{]}}}}}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{"newfw"}}] \leavevmode{[}{]}
nonmonotone method according to {\hyperref[\detokenize{index:bibliography}]{\sphinxcrossref{\DUrole{std,std-ref}{{[}2{]}}}}}

\end{description}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{gtol}: (\sphinxstyleemphasis{default}: \sphinxcode{1e-3})}] \leavevmode
tolerance for detecting convergence on the gradient

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{maxiter}: (\sphinxstyleemphasis{default}: \sphinxcode{2000})}] \leavevmode
maximum number of iterations allowed

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{verbose}: (\sphinxstyleemphasis{default}: \sphinxcode{1})}] \leavevmode
verbosity level. Current options:
- \sphinxcode{0}: only convergence info
- \sphinxcode{1}: only show time and final stats
- \sphinxcode{2}: show outer iterations
- \sphinxcode{3}: everything (except debug which is set separately)

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{changevar}: (\sphinxstyleemphasis{default}: \sphinxcode{False})}] \leavevmode
boolean option to allow for a change of variables before starting the 
method. Currently disabled due to bad performance.

\end{description}

\end{itemize}

\end{description}

Output:

\sphinxcode{solver}: \sphinxcode{ProcrustesSolver} instance
\index{\_setoptions() (skprocrustes.SPGSolver method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.SPGSolver._setoptions}}\pysiglinewithargsret{\sphinxbfcode{\_setoptions}}{\emph{options}}{}
Sets and validates options for the SPGSolver.

\sphinxstyleemphasis{This method should not be called directly; it is called by the 
SPGSolver constructor.}

\end{fulllineitems}

\index{solve() (skprocrustes.SPGSolver method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.SPGSolver.solve}}\pysiglinewithargsret{\sphinxbfcode{solve}}{\emph{problem}}{}
Effectively solve the problem using the SPG method.

Input:
\begin{quote}

\sphinxcode{problem}: \sphinxcode{ProcrustesProblem} instance
\end{quote}

Output:
\begin{quote}

\sphinxcode{result}: \sphinxcode{OptimizationResult} instance
\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{GKBSolver (class in skprocrustes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.GKBSolver}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{skprocrustes.}\sphinxbfcode{GKBSolver}}{\emph{**kwargs}}{}
Bases: \sphinxcode{skprocrustes.skprocrustes.SPGSolver}

Subclass containing the call to the \sphinxcode{spectral\_setup()} function 
corresponding to the Spectral Projected Gradient Method using 
incomplete Golub-Kahan Bidiagonalization (Lanczos) as described in 
{\hyperref[\detokenize{index:bibliography}]{\sphinxcrossref{\DUrole{std,std-ref}{{[}2{]}}}}}. This class extends the \sphinxcode{SPGSolver} class,
with some variation in the input and output parameters.

Usage example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mysolver} \PYG{o}{=} \PYG{n}{skp}\PYG{o}{.}\PYG{n}{GKBSolver}\PYG{p}{(}\PYG{n}{verbose}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result} \PYG{o}{=} \PYG{n}{mysolver}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{problem}\PYG{p}{)}
\end{sphinxVerbatim}

Input:
\begin{description}
\item[{\sphinxcode{key = value}: keyword arguments available}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{full\_results}: (\sphinxstyleemphasis{default}: \sphinxcode{False})}] \leavevmode
Return list of criticality values at each iteration (for later
comparison between solvers)

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{strategy}: (\sphinxstyleemphasis{default}: \sphinxcode{"newfw"})}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{"monotone"}: }] \leavevmode
monotone trust region

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{"bazfr"}}] \leavevmode{[}{]}
nonmonotone method according to {\hyperref[\detokenize{index:bibliography}]{\sphinxcrossref{\DUrole{std,std-ref}{{[}1{]}}}}}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{"newfw"}}] \leavevmode{[}{]}
nonmonotone method according to {\hyperref[\detokenize{index:bibliography}]{\sphinxcrossref{\DUrole{std,std-ref}{{[}2{]}}}}}

\end{description}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{gtol}: (\sphinxstyleemphasis{default}: \sphinxcode{1e-3})}] \leavevmode
tolerance for detecting convergence on the gradient

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{maxiter}: (\sphinxstyleemphasis{default}: \sphinxcode{2000})}] \leavevmode
maximum number of iterations allowed

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{verbose}: (\sphinxstyleemphasis{default}: \sphinxcode{1})}] \leavevmode
verbosity level. Current options:
- \sphinxcode{0}: only convergence info
- \sphinxcode{1}: only show time and final stats
- \sphinxcode{2}: show outer iterations
- \sphinxcode{3}: everything (except debug which is set separately)

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{changevar}: (\sphinxstyleemphasis{default}: \sphinxcode{False})}] \leavevmode
boolean option to allow for a change of variables before starting the 
method. Currently disabled due to bad performance.

\end{description}

\end{itemize}

\end{description}

Output:

\sphinxcode{solver}: \sphinxcode{ProcrustesSolver} instance

\begin{sphinxadmonition}{note}{Note:}
Since this subclass extends SPGSolver class, we use 
\sphinxcode{SPGSolver.\_setoptions} directly.
\end{sphinxadmonition}
\index{solve() (skprocrustes.GKBSolver method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.GKBSolver.solve}}\pysiglinewithargsret{\sphinxbfcode{solve}}{\emph{problem}}{}
Effectively solve the problem using the GKB method.

Input:
\begin{quote}

\sphinxcode{problem}: \sphinxcode{ProcrustesProblem} instance
\end{quote}

Output:
\begin{quote}

\sphinxcode{result}: \sphinxcode{OptimizationResult} instance
\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{EBSolver (class in skprocrustes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.EBSolver}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{skprocrustes.}\sphinxbfcode{EBSolver}}{\emph{**kwargs}}{}
Bases: \sphinxcode{skprocrustes.skprocrustes.ProcrustesSolver}

Subclass containing the call to the \sphinxcode{eb\_solver()} function 
corresponding to the Expansion-Balance method as described in 
{\hyperref[\detokenize{index:bibliography}]{\sphinxcrossref{\DUrole{std,std-ref}{{[}3{]}}}}}.

Usage example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mysolver} \PYG{o}{=} \PYG{n}{skp}\PYG{o}{.}\PYG{n}{EBSolver}\PYG{p}{(}\PYG{n}{verbose}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result} \PYG{o}{=} \PYG{n}{mysolver}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{problem}\PYG{p}{)}
\end{sphinxVerbatim}

Input:
\begin{description}
\item[{\sphinxcode{key = value}: keyword arguments available}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{full\_results}: (\sphinxstyleemphasis{default}: \sphinxcode{False})}] \leavevmode
Return list of criticality values at each iteration (for later
comparison between solvers)

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{tol}: (\sphinxstyleemphasis{default}: \sphinxcode{1e-6})}] \leavevmode
tolerance for detecting convergence

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{maxiter}: (\sphinxstyleemphasis{default}: \sphinxcode{2000})}] \leavevmode
maximum number of iterations allowed

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{verbose}: (\sphinxstyleemphasis{default}: \sphinxcode{1})}] \leavevmode
verbosity level. Current options:
- \sphinxcode{0}: only convergence info
- \sphinxcode{1}: only show time and final stats

\end{description}

\end{itemize}

\end{description}

Output:

\sphinxcode{solver}: \sphinxcode{ProcrustesSolver} instance
\index{\_setoptions() (skprocrustes.EBSolver method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.EBSolver._setoptions}}\pysiglinewithargsret{\sphinxbfcode{\_setoptions}}{\emph{options}}{}
Sets and validates options for the EBSolver.

\sphinxstyleemphasis{This method should not be called directly; it is called by the 
EBSolver constructor.}

\end{fulllineitems}

\index{solve() (skprocrustes.EBSolver method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.EBSolver.solve}}\pysiglinewithargsret{\sphinxbfcode{solve}}{\emph{problem}}{}
Effectively solve the problem using the Expansion-Balance method.

Input:
\begin{quote}

\sphinxcode{problem}: \sphinxcode{ProcrustesProblem} instance
\end{quote}

Output:
\begin{quote}

\sphinxcode{result}: \sphinxcode{OptimizationResult} instance
\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{GPISolver (class in skprocrustes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.GPISolver}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{skprocrustes.}\sphinxbfcode{GPISolver}}{\emph{**kwargs}}{}
Bases: \sphinxcode{skprocrustes.skprocrustes.ProcrustesSolver}

Subclass containing the call to the \sphinxcode{gpi\_solver()} function 
corresponding to the Generalized Power Iteration method as described in 
{\hyperref[\detokenize{index:bibliography}]{\sphinxcrossref{\DUrole{std,std-ref}{{[}5{]}}}}}.

Usage example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mysolver} \PYG{o}{=} \PYG{n}{skp}\PYG{o}{.}\PYG{n}{GPISolver}\PYG{p}{(}\PYG{n}{verbose}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result} \PYG{o}{=} \PYG{n}{mysolver}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{problem}\PYG{p}{)}
\end{sphinxVerbatim}

Input:
\begin{description}
\item[{\sphinxcode{key = value}: keyword arguments available}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{full\_results}: (\sphinxstyleemphasis{default}: \sphinxcode{False})}] \leavevmode
Return list of criticality values at each iteration (for later
comparison between solvers)

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{tol}: (\sphinxstyleemphasis{default}: \sphinxcode{1e-3})}] \leavevmode
tolerance for detecting convergence

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{maxiter}: (\sphinxstyleemphasis{default}: \sphinxcode{2000})}] \leavevmode
maximum number of iterations allowed

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{verbose}: (\sphinxstyleemphasis{default}: \sphinxcode{1})}] \leavevmode
verbosity level. Current options:
- \sphinxcode{0}: only convergence info
- \sphinxcode{1}: only show time and final stats

\end{description}

\end{itemize}

\end{description}

Output:

\sphinxcode{solver}: \sphinxcode{ProcrustesSolver} instance
\index{\_setoptions() (skprocrustes.GPISolver method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.GPISolver._setoptions}}\pysiglinewithargsret{\sphinxbfcode{\_setoptions}}{\emph{options}}{}
Sets and validates options for the GPISolver.

\sphinxstyleemphasis{This method should not be called directly; it is called by the 
GPISolver constructor.}

\end{fulllineitems}

\index{solve() (skprocrustes.GPISolver method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.GPISolver.solve}}\pysiglinewithargsret{\sphinxbfcode{solve}}{\emph{problem}}{}
Effectively solve the problem using the Generalized Power Iteration
method.

Input:
\begin{quote}

\sphinxcode{problem}: \sphinxcode{ProcrustesProblem} instance
\end{quote}

Output:
\begin{quote}

\sphinxcode{result}: \sphinxcode{OptimizationResult} instance
\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{spectral\_solver() (in module skprocrustes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.spectral_solver}}\pysiglinewithargsret{\sphinxcode{skprocrustes.}\sphinxbfcode{spectral\_solver}}{\emph{problem}, \emph{largedim}, \emph{smalldim}, \emph{X}, \emph{A}, \emph{B}, \emph{solvername}, \emph{options}}{}
Nonmonotone Spectral Projected Gradient solver for problems of the type
\begin{quote}
\begin{equation*}
\begin{split}\min \lVert AXC - B\rVert_F^2  \qquad s.t. X^TX = I\end{split}
\end{equation*}\end{quote}

The method is described in references {[}1{]} and {[}2{]}, and we implement a few
variations (including a monotone version, a nonmonotone version using the 
strategy described in {[}1{]}, and a nonmonotone version using the strategy 
described in {[}2{]}; check below for more details on how to select these 
different algorithms).

This function is called by \sphinxcode{spectral\_solver} from both GKBSolver and
SPGSolver, with different parameters.

Input:
\begin{itemize}
\item {} 
\sphinxcode{problem}: \sphinxcode{ProcrustesProblem} instance

\item {} 
\sphinxcode{largedim}: \sphinxcode{int}

\item {} \begin{description}
\item[{\sphinxcode{smalldim}: \sphinxcode{int}}] \leavevmode
Since this function is called by \sphinxcode{spectral\_solver}, it is possible
we are solving a smaller version of the original problem (when using
GKBSolver, for instance). Thus, \sphinxcode{lagedim} and \sphinxcode{smalldim} are the
dimensions of the current problem being solved by \sphinxcode{spectral\_solver}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{X}: \sphinxcode{ndarray(smalldim, p)}}] \leavevmode
Initial guess for the solution X of the Procrustes Problem being solved.

\end{description}

\item {} 
\sphinxcode{A}: \sphinxcode{ndarray(largedim, smalldim)}

\item {} 
\sphinxcode{B}: \sphinxcode{ndarray(largedim, q)}

\item {} \begin{description}
\item[{\sphinxcode{solvername}: str}] \leavevmode
Takes values \sphinxcode{spg} or \sphinxcode{gkb} (used to decide if \sphinxcode{full\_results} can 
be reported).

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{options}: \sphinxcode{dict}}] \leavevmode\begin{description}
\item[{Solver options. Keys available are:}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{maxiter}: \sphinxcode{int}}] \leavevmode
Maximum number of iterations allowed

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{strategy}: \sphinxcode{str}}] \leavevmode
\sphinxcode{monot} (Monotone strategy), \sphinxcode{bazfr} (Nonmonotone strategy 
described in {[}1{]}) or \sphinxcode{newfw} (Nonmonotone strategy described 
in {[}2{]})

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{verbose}: \sphinxcode{int}}] \leavevmode
Can take values in (0,1,2,3)

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{gtol}: \sphinxcode{float}}] \leavevmode
Tolerance for convergence.

\end{description}

\end{itemize}

\end{description}

\end{description}

\end{itemize}

Output:
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{exitcode}: \sphinxcode{int}}] \leavevmode
0 (success) or 1 (failure)

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{f}: \sphinxcode{float}}] \leavevmode
Value of the objective function at final iterate

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{X}: \sphinxcode{ndarray(smalldim, p)}}] \leavevmode
Approximate solution (final iterate)

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{normg}: \sphinxcode{float}}] \leavevmode
Criticality measure at final iterate

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{outer}: \sphinxcode{int}}] \leavevmode
Final number of outer iterations performed.

\end{description}

\end{itemize}

References:
\begin{description}
\item[{{[}1{]} J.B. Francisco, F.S. Viloche Bazán, Nonmonotone algorithm for }] \leavevmode
minimization on closed sets with applications to minimization on 
Stiefel manifolds, Journal of Computational and Applied Mathematics, 
2012, 236(10): 2717\textendash{}2727 \textless{}\sphinxurl{http://dx.doi.org/10.1016/j.cam.2012.01.014}\textgreater{}

\item[{{[}2{]} J.B. Francisco, F.S. Viloche Bazán and M. Weber Mendonça, Non-monotone }] \leavevmode
algorithm for minimization on arbitrary domains with applications to 
large-scale orthogonal Procrustes problem, Appl. Num. Math., 2017, 
112: 51\textendash{}64 \textless{}\sphinxurl{https://doi.org/10.1016/j.apnum.2016.09.018}\textgreater{}

\end{description}

\end{fulllineitems}

\index{eb\_solver() (in module skprocrustes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.eb_solver}}\pysiglinewithargsret{\sphinxcode{skprocrustes.}\sphinxbfcode{eb\_solver}}{\emph{problem}, \emph{options}}{}
Expansion-Balance solver as presented in {[}1{]}

Here we consider always \(m=n\), \(p=q\), \(C=I\).
Thus the problem has to be
\begin{quote}
\begin{equation*}
\begin{split}\min \lVert A_{n\times n}X_{n\times p}-B_{n\times p}\rVert_F^2 
\qquad s.t. X^TX=I_{p\times p}    \end{split}
\end{equation*}\end{quote}

References:
\begin{description}
\item[{{[}1{]} Zhang, Du - Successive projection method for solving the}] \leavevmode
unbalanced Procrustes problem

\item[{{[}2{]} Green B. F., Goers J. C. - A problem with Congruence. The Annual}] \leavevmode
Meeting of the Psychometric Society, Monterey,
California 1979.

\item[{{[}3{]} Ten Berge J. M. F., Konl D. L. - Orthogonal rotations to maximal}] \leavevmode
agreement for two of more matrices of different column
orders. Psychometrica, 1984, 49:49-55.

\end{description}

\end{fulllineitems}

\index{gpi\_solver() (in module skprocrustes)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{skprocrustes:skprocrustes.gpi_solver}}\pysiglinewithargsret{\sphinxcode{skprocrustes.}\sphinxbfcode{gpi\_solver}}{\emph{problem}, \emph{options}}{}
Generalized Power Iteration solver as presented in {[}1{]}

Here we consider always C=I.
Thus the problem has to be
\begin{quote}
\begin{equation*}
\begin{split}\min \lVert A_{m\times n}X_{n\times p}-B_{m\times p}\rVert_F^2 
\qquad s.t. X^TX=I_{p\times p}    \end{split}
\end{equation*}\end{quote}

References:
\begin{description}
\item[{{[}1{]} F. Nie, R. Zhang, X. Li, A generalized power iteration method for}] \leavevmode
solving quadratic problem on the Stiefel manifold, Sci. China Inf. Sci.,
2017, 60: 112101:1\textendash{}112101:10.
\textless{}\sphinxurl{http://dx.doi.org/10.1007/s11432-016-9021-9}\textgreater{}

\end{description}

\end{fulllineitems}



\section{Solvers}
\label{\detokenize{solvers:solvers}}\label{\detokenize{solvers::doc}}

\subsection{GKB Solver}
\label{\detokenize{solvers:gkb-solver}}\label{\detokenize{solvers:gkb}}
Nonmonotone Spectral Projected Gradient Method for the (unbalanced) WOPP, using incomplete Golub-Kahan Bidiagonalization as described in %
\begin{footnote}[2]\sphinxAtStartFootnote
J.B. Francisco, F.S. Viloche Bazán and M. Weber Mendonça, Non-monotone algorithm for minimization on arbitrary domains with applications to large-scale orthogonal Procrustes problem, Applied Numerical Mathematics, 112: 51\textendash{}64 2017 \textless{}\sphinxurl{https://doi.org/10.1016/j.apnum.2016.09.018}\textgreater{}
%
\end{footnote}.


\subsection{SPG Solver}
\label{\detokenize{solvers:spg}}\label{\detokenize{solvers:spg-solver}}
Nonmonotone Spectral Projected Gradient Method for the (unbalanced) WOPP, as described in %
\begin{footnote}[1]\sphinxAtStartFootnote
J.B. Francisco, F.S. Viloche Bazán, Nonmonotone algorithm for minimization on closed sets with applications to minimization on Stiefel manifolds, Journal of Computational and Applied Mathematics, 236(10): 2717\textendash{}2727, 2012 \textless{}\sphinxurl{http://dx.doi.org/10.1016/j.cam.2012.01.014}\textgreater{}
%
\end{footnote}, \sphinxfootnotemark[2].


\subsection{EB Solver}
\label{\detokenize{solvers:eb}}\label{\detokenize{solvers:eb-solver}}
Expansion-balance solver, as described in %
\begin{footnote}[3]\sphinxAtStartFootnote
J.M.F. ten Berge and D.L. Knol, Orthogonal rotations to maximal agreement for two or more matrices of different column orders, Psychometrika 49: 49. \textless{}\sphinxurl{https://doi:10.1007/BF02294205}\textgreater{}
%
\end{footnote}.


\subsection{GPI Solver}
\label{\detokenize{solvers:gpi}}\label{\detokenize{solvers:gpi-solver}}
Generalized Power Iteration solver for the WOPP, as described in %
\begin{footnote}[5]\sphinxAtStartFootnote
\begin{enumerate}
\setcounter{enumi}{5}
\item {} 
Nie, R. Zhang, X. Li, A generalized power iteration method for solving quadratic problem on the Stiefel manifold, Sci. China Inf. Sci., 2017, 60: 112101:1\textendash{}112101:10. \textless{}\sphinxurl{http://dx.doi.org/10.1007/s11432-016-9021-9}\textgreater{}

\end{enumerate}
%
\end{footnote}.


\subsection{References}
\label{\detokenize{solvers:references}}

\section{BSD 2-Clause License}
\label{\detokenize{license:bsd-2-clause-license}}\label{\detokenize{license::doc}}
Copyright (c) 2017, Melissa Weber Mendonça
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
\begin{itemize}
\item {} 
Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

\item {} 
Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

\end{itemize}

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS”
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


\section{Authors}
\label{\detokenize{authors:authors}}\label{\detokenize{authors::doc}}
Melissa Weber Mendonça

\sphinxstyleemphasis{Department of Mathematics}

\sphinxstyleemphasis{Federal University of Santa Catarina (UFSC)}

\sphinxstyleemphasis{Florianópolis, SC - Brasil}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{s}
\item {\sphinxstyleindexentry{skprocrustes}}\sphinxstyleindexpageref{skprocrustes:\detokenize{module-skprocrustes}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}